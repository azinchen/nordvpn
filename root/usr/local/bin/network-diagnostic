#!/bin/sh
# vpn-diag: POSIX sh network diagnostics for an OpenVPN-connected system (Docker-friendly)
# Usage: vpn-diag [--basic|-b] | [--full|-f] | [--help|-h]
# Default mode is --full.

set -u  # be strict about undefined vars

MODE="full"

print_usage()
{
    cat <<'EOF'
Usage: vpn-diag [options]

Options:
    -b, --basic   Print only: "Public IP address X.X.X.X, location City CC"
    -f, --full    Full diagnostics (default)
    -h, --help    Show this help
EOF
}

# ---- Parse CLI --------------------------------------------------------------
while [ "$#" -gt 0 ]; do
    case "$1" in
        -b|--basic) MODE="basic" ;;
        -f|--full)  MODE="full"  ;;
        -h|--help)  print_usage; exit 0 ;;
        *) echo "Unknown option: $1" >&2; print_usage; exit 2 ;;
    esac
    shift
done

. /usr/local/bin/backend-functions

# ---- Tool discovery ---------------------------------------------------------
NFT_BIN="$(command -v nft 2>/dev/null || printf '')"
TR_BIN="$(command -v traceroute 2>/dev/null || printf '')"
[ -n "$TR_BIN" ] || TR_BIN="$(command -v tracepath 2>/dev/null || printf '')"

# ---- Public IP helpers (prefer ipinfo.io) ----------------------------------
fetch_public_info()
{
    IP=""; CITY=""; CC=""
    RESP="$(curl -s --max-time 4 https://ipinfo.io/json 2>/dev/null || printf '')"
    if [ -n "$RESP" ]; then
        IP="$(printf "%s" "$RESP" | jq -r '.ip // empty' 2>/dev/null || printf '')"
        CITY="$(printf "%s" "$RESP" | jq -r '.city // empty' 2>/dev/null || printf '')"
        CC="$(printf "%s" "$RESP" | jq -r '.country // empty' 2>/dev/null || printf '')"
    fi
    if [ -z "$IP" ]; then
        IP="$(curl -s --max-time 4 https://ifconfig.co 2>/dev/null || printf '')"
        CITY="$(curl -s --max-time 4 https://ifconfig.co/city 2>/dev/null || printf '')"
        CC="$(curl -s --max-time 4 https://ifconfig.co/country-iso 2>/dev/null || printf '')"
    fi
}

print_basic()
{
    fetch_public_info
    if [ -n "$IP" ]; then
        echo "Public IP address $IP, location ${CITY:-Unknown} ${CC:-??}"
        exit 0
    else
        echo "Public IP address Unknown, location Unknown ??"
        exit 1
    fi
}

# If basic mode requested, do that and exit early.
if [ "$MODE" = "basic" ]; then
    print_basic
fi

# ---- Helpers: DNS nameserver geolocation & RTT ------------------------------
is_private_ip()
{
    case "$1" in
        10.*|192.168.*|172.1[6-9].*|172.2[0-9].*|172.3[0-1].*) return 0 ;;
        fd*|FD*|fc*|FC*|fe80*|FE80*) return 0 ;;
        *) return 1 ;;
    esac
}

# Query OpenVPN management interface for connection details
get_openvpn_status()
{
    # Try to connect to OpenVPN management interface
    if command -v nc >/dev/null 2>&1; then
        # Use netcat to query management interface
        MGMT_RESP="$(printf "status\nquit\n" | nc -w 2 127.0.0.1 7505 2>/dev/null || printf '')"
    elif command -v telnet >/dev/null 2>&1 && command -v timeout >/dev/null 2>&1; then
        # Fallback to telnet with timeout
        MGMT_RESP="$(printf "status\nquit\n" | timeout 2 telnet 127.0.0.1 7505 2>/dev/null | sed -n '/^END/,/^END/p' || printf '')"
    else
        MGMT_RESP=""
    fi
    
    # Parse the response for connection details
    if [ -n "$MGMT_RESP" ]; then
        # For client connections, try to extract from different lines
        # Look for remote server info in the status output
        COMMON_NAME="$(printf "%s" "$MGMT_RESP" | grep -o 'TCP connection established with \[AF_INET\][0-9.]*:[0-9]*' | sed 's/.*\[\([^]]*\)\].*/\1/' | cut -d: -f1 || printf '')"
        
        # Extract remote IP from status (TCP or UDP)
        TCP_LINE="$(printf "%s" "$MGMT_RESP" | grep 'TCP connection established' | head -1 || printf '')"
        UDP_LINE="$(printf "%s" "$MGMT_RESP" | grep 'UDPv4 link remote' | head -1 || printf '')"
        
        if [ -n "$TCP_LINE" ]; then
            TRUSTED_IP="$(printf "%s" "$TCP_LINE" | sed 's/.*\[AF_INET\]\([0-9.]*\):.*/\1/' || printf '')"
        elif [ -n "$UDP_LINE" ]; then
            TRUSTED_IP="$(printf "%s" "$UDP_LINE" | sed 's/.*\[AF_INET\]\([0-9.]*\):.*/\1/' || printf '')"
        fi
        
        # Try to get port from management interface state
        STATE_RESP="$(printf "state\nquit\n" | nc -w 2 127.0.0.1 7505 2>/dev/null || printf '')"
        if [ -n "$STATE_RESP" ]; then
            # Parse state line: >STATE:timestamp,connected,remote_ip,remote_port,local_ip,local_port
            STATE_LINE="$(printf "%s" "$STATE_RESP" | grep '^>STATE:' | head -1 || printf '')"
            if [ -n "$STATE_LINE" ]; then
                STATE_IP="$(printf "%s" "$STATE_LINE" | cut -d, -f3 || printf '')"
                STATE_PORT="$(printf "%s" "$STATE_LINE" | cut -d, -f4 || printf '')"
                [ -n "$STATE_IP" ] && [ "$STATE_IP" != "0.0.0.0" ] && TRUSTED_IP="$STATE_IP"
                [ -n "$STATE_PORT" ] && [ "$STATE_PORT" != "0" ] && TRUSTED_PORT="$STATE_PORT"
            fi
        fi
    fi
    
    # Fallback: try to get from config file if management interface didn't work
    if [ -z "$COMMON_NAME" ] && [ -f "/run/xt/nordvpn.ovpn" ]; then
        # Extract from verify-x509-name line first (preferred)
        COMMON_NAME="$(awk '/^[[:space:]]*verify-x509-name/ {for(i=1;i<=NF;i++) if($i ~ /CN=/) {sub(/CN=/,"",$i); print $i; exit}}' "/run/xt/nordvpn.ovpn" 2>/dev/null || printf '')"
        if [ -z "$COMMON_NAME" ]; then
            # Fallback to remote hostname/IP
            REMOTE_VAL="$(awk '/^[[:space:]]*remote[ \t]+/ {print $2; exit}' "/run/xt/nordvpn.ovpn" 2>/dev/null || printf '')"
            # If it's an IP address, try to construct hostname
            if printf "%s" "$REMOTE_VAL" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' >/dev/null 2>&1; then
                # It's an IP, we can't easily get hostname, so leave empty for now
                COMMON_NAME=""
            else
                COMMON_NAME="$REMOTE_VAL"
            fi
        fi
    fi
    if [ -z "$TRUSTED_IP" ] && [ -f "/run/xt/nordvpn.ovpn" ]; then
        TRUSTED_IP="$(awk '/^[[:space:]]*remote[ \t]+/ {print $2; exit}' "/run/xt/nordvpn.ovpn" 2>/dev/null || printf '')"
        TRUSTED_PORT="$(awk '/^[[:space:]]*remote[ \t]+/ {print $3; exit}' "/run/xt/nordvpn.ovpn" 2>/dev/null || printf '')"
        [ -z "$TRUSTED_PORT" ] && TRUSTED_PORT="$(awk '/^[[:space:]]*port[ \t]+/ {print $2; exit}' "/run/xt/nordvpn.ovpn" 2>/dev/null || printf '')"
    fi
}

# Get OpenVPN interface details from system
get_interface_details()
{
    # Get device type (tun/tap)
    DEV_TYPE="$(ip link show "$DEV_IF" 2>/dev/null | awk -F: '/^[0-9]+:.*tun[0-9]*:/ {print "tun"} /^[0-9]+:.*tap[0-9]*:/ {print "tap"}' || printf '?')"
    
    # Get local IP from interface
    IFCONF_LOCAL="$(ip addr show "$DEV_IF" 2>/dev/null | awk '/inet / {split($2,a,"/"); print a[1]; exit}' || printf '?')"
    
    # For OpenVPN tun interface, remote IP is typically local_ip + 1 or from peer address
    if [ "$IFCONF_LOCAL" != "?" ]; then
        # Calculate remote IP (usually .1 for local, .2 for remote in /30 subnet)
        # Split IP address using POSIX-compatible method
        a="$(printf "%s" "$IFCONF_LOCAL" | cut -d. -f1)"
        b="$(printf "%s" "$IFCONF_LOCAL" | cut -d. -f2)"
        c="$(printf "%s" "$IFCONF_LOCAL" | cut -d. -f3)"
        d="$(printf "%s" "$IFCONF_LOCAL" | cut -d. -f4)"
        if [ "$d" = "1" ]; then
            IFCONF_REMOTE="$a.$b.$c.2"
        elif [ "$d" = "2" ]; then
            IFCONF_REMOTE="$a.$b.$c.1"
        else
            IFCONF_REMOTE="?"
        fi
    else
        IFCONF_REMOTE="?"
    fi
    
    # Get VPN gateway from routes (usually the remote IP)
    ROUTE_VPN_GW="$IFCONF_REMOTE"
}

ns_geo_line()
{
    IPQ="$1"
    if is_private_ip "$IPQ"; then
        echo "$IPQ : (private/local resolver)"
        return
    fi

    CITY=""; CC=""; ORG=""
    RESP="$(curl -s --max-time 4 "https://ipinfo.io/$IPQ/json" 2>/dev/null || printf '')"
    if [ -n "$RESP" ]; then
        CITY="$(printf "%s" "$RESP" | jq -r '.city // empty' 2>/dev/null || printf '')"
        CC="$(printf "%s" "$RESP" | jq -r '.country // empty' 2>/dev/null || printf '')"
        ORG="$(printf "%s" "$RESP" | jq -r '.org // empty' 2>/dev/null || printf '')"
    fi
    if [ -z "$CITY$CC$ORG" ]; then
        RESP="$(curl -s --max-time 4 "https://ipapi.co/$IPQ/json/" 2>/dev/null || printf '')"
        if [ -n "$RESP" ]; then
                CITY="$(printf "%s" "$RESP" | jq -r '.city // empty' 2>/dev/null || printf '')"
                CC="$(printf "%s" "$RESP" | jq -r '.country // empty' 2>/dev/null || printf '')"
                [ -n "$CC" ] || CC="$(printf "%s" "$RESP" | jq -r '.country_code // empty' 2>/dev/null || printf '')"
                ORG="$(printf "%s" "$RESP" | jq -r '.org // empty' 2>/dev/null || printf '')"
        fi
    fi
    [ -n "$CITY" ] || CITY="Unknown"
    [ -n "$CC" ] || CC="??"
    if [ -n "$ORG" ]; then
        echo "$IPQ : $CITY $CC â€” $ORG"
    else
        echo "$IPQ : $CITY $CC"
    fi
}

ns_rtt()
{
    NS="$1"
    POUT="$(ping -w 2 -c 2 "$NS" 2>/dev/null | awk -F'[/ ]' '/^rtt|^round-trip/{print $(NF-2)" ms"}')"
    [ -n "$POUT" ] && echo "  (avg RTT: $POUT)"
}

print_dns_geo()
{
    echo "### DNS servers geolocation"
    NS_LIST="$(awk '/^nameserver/ {print $2}' /etc/resolv.conf 2>/dev/null | sed 's/%.*//' | sort -u)"
    if [ -z "$NS_LIST" ]; then
        NS_LIST="$(resolvectl dns 2>/dev/null | tr ' ' '\n' | sed 's/%.*//' | \
            grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$|^[0-9a-fA-F:]+$' | sort -u)"
    fi
    if [ -z "$NS_LIST" ]; then
        echo "(no nameservers found)"
        echo
        return
    fi
    for NS in $NS_LIST; do
        ns_geo_line "$NS"
        ns_rtt "$NS"
    done
    echo
}

# ---- Full diagnostics (default) --------------------------------------------
PUBLIC_TEST_IPv4="1.1.1.1"
PUBLIC_TEST_IPv6="2606:4700:4700::1111"

# Initialize variables with defaults
COMMON_NAME=""
DEV_IF="tun0"
DEV_TYPE="?"
IFCONF_LOCAL="?"
IFCONF_REMOTE="?"
ROUTE_VPN_GW="?"
TRUSTED_IP=""
TRUSTED_PORT=""
PROTO="?"
LPORT="?"

# Try to get OpenVPN status from management interface
get_openvpn_status

# Get interface details from system
get_interface_details

# Try to get protocol and port from OpenVPN config or process
if [ -f "/run/xt/nordvpn.ovpn" ]; then
    # Try to extract from config file
    PROTO="$(awk '/^[[:space:]]*proto[ \t]+/ {print tolower($2); exit}' "/run/xt/nordvpn.ovpn" || printf '?')"
    LPORT="$(awk '/^[[:space:]]*port[ \t]+/ {print $2; exit}' "/run/xt/nordvpn.ovpn" || printf '?')"
    if [ -z "$LPORT" ] || [ "$LPORT" = "?" ]; then
        # Try from remote line
        LPORT="$(awk '/^[[:space:]]*remote[ \t]+/ {print $3; exit}' "/run/xt/nordvpn.ovpn" | grep '^[0-9]*$' || printf '?')"
    fi
elif command -v pgrep >/dev/null 2>&1 && command -v ps >/dev/null 2>&1; then
    OVPN_PID="$(pgrep -f openvpn || printf '')"
    if [ -n "$OVPN_PID" ]; then
        # Try to extract from process command line
        OVPN_CMD="$(ps -p "$OVPN_PID" -o args= 2>/dev/null || printf '')"
        PROTO="$(printf "%s" "$OVPN_CMD" | grep -o '\-\-proto [a-zA-Z0-9]*' | awk '{print $2}' | tr 'A-Z' 'a-z' || printf '?')"
        LPORT="$(printf "%s" "$OVPN_CMD" | grep -o '\-\-lport [0-9]*\|\-\-port [0-9]*' | awk '{print $2}' | tail -1 || printf '?')"
        [ -z "$LPORT" ] && LPORT="$(printf "%s" "$OVPN_CMD" | grep -o '\-\-remote [0-9.]* [0-9]*' | awk '{print $3}' || printf '?')"
    fi
fi

# Format trusted peer display
if [ -n "$TRUSTED_IP" ] && [ -n "$TRUSTED_PORT" ]; then
    TRUSTED_PEER="$TRUSTED_IP:$TRUSTED_PORT"
elif [ -n "$TRUSTED_IP" ]; then
    TRUSTED_PEER="$TRUSTED_IP:?"
else
    TRUSTED_PEER="?:?"
fi

echo "================================================================"
echo "OpenVPN DIAG (full)   : $(date -Is 2>/dev/null || date)"
echo "Device                : $DEV_IF (type=$DEV_TYPE)"
echo "Common Name           : $COMMON_NAME"
echo "Ifconfig Local        : $IFCONF_LOCAL"
echo "Ifconfig Remote       : $IFCONF_REMOTE"
echo "Route VPN Gateway     : $ROUTE_VPN_GW"
echo "Trusted Peer          : $TRUSTED_PEER"
echo "Proto/Local Port      : $PROTO/$LPORT"
echo

echo "### ip addr show $DEV_IF"
ip addr show "$DEV_IF" 2>/dev/null || true
echo

echo "### ip link (up)"
ip -brief link show up 2>/dev/null || true
echo

echo "### ip route (main)"
ip route show 2>/dev/null || true
echo

echo "### ip rule"
ip rule show 2>/dev/null || true
echo

# Default route / split-default detection
DEF_DEV="$(ip route show default 2>/dev/null | awk '/default/{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"
DEV0="$(ip route show '0.0.0.0/1' 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"
DEV128="$(ip route show '128.0.0.0/1' 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"

if [ -n "$DEV0" ] && [ -n "$DEV128" ] && [ "$DEV0" = "$DEV_IF" ] && [ "$DEV128" = "$DEV_IF" ]; then
    echo "Default route dev     : (split default) $DEV_IF (0.0.0.0/1 + 128.0.0.0/1)"
    echo "[ok] Full-tunnel via split default detected"
else
    [ -n "${DEF_DEV:-}" ] || DEF_DEV="<none>"
    echo "Default route dev     : $DEF_DEV"
    if [ "$DEF_DEV" = "$DEV_IF" ]; then
        echo "[ok] Default route is via $DEV_IF"
    else
        echo "[warn] Default route is NOT via $DEV_IF"
    fi
fi
echo

echo "### ip route get $PUBLIC_TEST_IPv4"
ip route get "$PUBLIC_TEST_IPv4" 2>/dev/null || true
echo

echo "### ip -6 route get $PUBLIC_TEST_IPv6"
ip -6 route get "$PUBLIC_TEST_IPv6" 2>/dev/null || echo "[info] no IPv6 route"
echo

# Netfilter snapshot
echo "### nftables / iptables rules"
if [ -n "$NFT_BIN" ]; then
    "$NFT_BIN" list ruleset 2>/dev/null || echo "[info] nft present, empty ruleset or no perms"
else
    echo "[info] nft not present"
fi

echo
echo "### iptables -S (filter)"
run4 -S 2>/dev/null || true

echo
echo "### iptables -t nat -S (IPv4 NAT)"
run4 -t nat -S 2>/dev/null || echo "(no IPv4 NAT rules or table unavailable)"

# Optional counters view (comment out if too verbose)
# echo
# echo "### iptables -t nat -L -n -v (counters)"
# "$IPT" -t nat -L -n -v 2>/dev/null || true

if [ -n "${IP6T}" ]; then
    echo
    echo "### ip6tables -S (filter)"
    run6 -S 2>/dev/null || true

    echo
    echo "### ip6tables -t nat -S (IPv6 NAT)"
    run6 -t nat -S 2>/dev/null || echo "(no IPv6 NAT rules or table unavailable)"
fi
echo

# Public IP & rough geo (JSON from same provider as summary)
echo "### Public IP / Geo (best-effort)"
RESP="$(curl -s --max-time 4 https://ipinfo.io/json 2>/dev/null || printf '')"
if [ -z "$RESP" ]; then
    RESP="$(curl -s --max-time 4 https://ifconfig.co/json 2>/dev/null || printf '')"
fi
if [ -n "$RESP" ]; then
    echo "$RESP" | jq . 2>/dev/null || echo "$RESP"
else
    echo "[warn] could not fetch public info"
fi
echo

# DNS configuration & identity probe
echo "### DNS configuration"
resolvectl status "$DEV_IF" 2>/dev/null || resolvectl status 2>/dev/null || true
echo

print_dns_geo

# Resolver identity (with fallbacks)
NS_ACTIVE="$(awk '/^nameserver/ {print $2; exit}' /etc/resolv.conf 2>/dev/null)"
if [ -n "$NS_ACTIVE" ]; then
    echo "### resolver identity via $NS_ACTIVE"
    OUT="$(dig +timeout=3 +short TXT whoami.cloudflare @"$NS_ACTIVE" 2>/dev/null | sed -n '1p')"
    if [ -z "$OUT" ]; then
        OUT="$(dig +timeout=3 +short CHAOS TXT id.server @"$NS_ACTIVE" 2>/dev/null | sed -n '1p')"
    fi
    if [ -z "$OUT" ]; then
        OUT="$(dig +timeout=3 +short CHAOS TXT hostname.bind @"$NS_ACTIVE" 2>/dev/null | sed -n '1p')"
    fi
    if [ -n "$OUT" ]; then
        echo "$OUT"
    else
        echo "(no identity TXT available from resolver)"
    fi
    echo
fi

# Connectivity probes
echo "### Ping checks"
ping -w 3 -c 3 "$PUBLIC_TEST_IPv4" 2>&1 || echo "[warn] ping to $PUBLIC_TEST_IPv4 failed"
ping6 -w 3 -c 3 "$PUBLIC_TEST_IPv6" 2>&1 || echo "[info] ping6 to $PUBLIC_TEST_IPv6 failed"
echo

if [ -n "$TR_BIN" ]; then
    echo "### Short trace to $PUBLIC_TEST_IPv4 (first hop should be VPN)"
    BN="$(basename "$TR_BIN" 2>/dev/null)"
    case "$BN" in
        tracepath) "$TR_BIN" -n -m 4 "$PUBLIC_TEST_IPv4" 2>&1 || true ;;
        *)         "$TR_BIN" -n -m 4 -w 2 "$PUBLIC_TEST_IPv4" 2>&1 || true ;;
    esac
    echo
fi

# Quick verdicts
echo "### Quick verdicts"
ROUTE_DEV="$(ip route get "$PUBLIC_TEST_IPv4" 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"
if [ -n "$ROUTE_DEV" ] && [ "$ROUTE_DEV" = "$DEV_IF" ]; then
    echo "[ok] Route to $PUBLIC_TEST_IPv4 goes via $DEV_IF"
else
    echo "[warn] Route to $PUBLIC_TEST_IPv4 uses ${ROUTE_DEV:-<none>} (expected $DEV_IF)"
fi

fetch_public_info
if [ -n "${IP:-}" ]; then
    echo "Public IPv4 seen     : $IP"
    [ -n "$CITY" ] || CITY="Unknown"
    [ -n "$CC" ] || CC="??"
    echo "Location             : $CITY $CC"
fi

echo "Done."
echo "================================================================"
echo
exit 0
